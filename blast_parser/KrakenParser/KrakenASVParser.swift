//
//  KrakenASVParser.swift
//  blast_parser
//
//  Created by Jo√£o Varela on 27/10/2024.
//

import Foundation

enum ASVFormat {
    case standard
    case epi2me
}

final class KrakenASVParser: FileParser {
    var binArray = KrakenASVBinArray()
    
    func parse(format:ASVFormat = .standard) throws {
        if format == .standard {
            try parseASVStandard()
        } else {
            try parseEpi2Me()
        }
    }
    
    /// Parses the original ASV table as generated by Kraken2 with the following format:
    /// U/C sequenceID taxon(taxID) length LCA (k-mer score string per taxon with the
    /// Lowest Common Ancestor)
    func parseASVStandard() throws {
        var i = 1
        for line in readStream {
            do {
                let items = line.components(separatedBy: "\t")
                guard items.count == 5 else { throw RuntimeError("Invalid ASV file")}
                guard let taxonomy = KrakenASVTaxonomy(classification: items[2])
                    else { throw RuntimeError("ASV with invalid taxonomy")}
                let size = Int(items[3].trimmingCharacters(in: .whitespaces)) ?? 0
                let asv = KrakenASV(sequenceID: items[1],
                                    length: size,
                                    taxonomy: taxonomy)
                binArray.append(asv: asv)
            }
            
            i += 1
        }
    }
    
    /// Parses the original ASV table as generated by Kraken2 in the Epi2Me software
    /// with the following 6-column format:
    /// U/C sequenceID taxID length LCA lineage
    func parseEpi2Me() throws {
        var i = 1
        for line in readStream {
            do {
                let items = line.components(separatedBy: "\t")
                guard items.count == 6 else { throw RuntimeError("Invalid ASV file")}
                let taxID = Int(items[2].trimmingCharacters(in: .whitespaces)) ?? 0
                let size = Int(items[3].trimmingCharacters(in: .whitespaces)) ?? 0
                let taxonomy = KrakenASVTaxonomy(taxID:taxID,
                                                 classification: items[5])
                let asv = KrakenASV(sequenceID: items[1],
                                    length: size,
                                    taxonomy: taxonomy)
                binArray.append(asv: asv)
            }
            
            i += 1
        }
        
        binArray.sort()
    }
}

