//
//  KrakenASV.swift
//  blast_parser
//
//  Created by JoÃ£o Varela on 27/10/2024.
//

import Foundation

enum ASVFormat {
    case standard
    case epi2me
    case parsed
}

struct KrakenASV: CustomStringConvertible {
    let sequenceID:String
    let length:Int
    var assignedReads:Int
    let taxonomy:KrakenASVTaxonomy
    
    var description:String {
        return """
                    \(sequenceID)\t\
                    \(length)\t\
                    \(assignedReads)\t\
                    \(taxonomy.taxID)\t\
                    \(taxonomy.taxon)
               """
    }
    
    init(sequenceID:String,
         length:Int,
         assignedReads:Int = 0,
         taxonomy:KrakenASVTaxonomy) {
        self.sequenceID = sequenceID
        self.length = length
        self.assignedReads = assignedReads
        self.taxonomy = taxonomy
    }
    
    /// Initializer to parse a Kraken2 ASV line
    /// - parameters:
    ///    - line: line to be parsed
    ///    - format: format of the line
    ///     - `.standard` if the line is in a Kraken2 standard format
    ///     - `.epi2me` if the line is in a Epi2Me Kraken2 format
    ///     - `.parsed` if the line was already parsed by blast_parser
    init(line:String, format:ASVFormat) throws {
        switch format {
        case .standard:
            self = try .parseASVStandard(line: line)
        case .epi2me:
            self = try .parseEpi2Me(line: line)
        case .parsed:
            self = try .parseParsedASV(line: line)
        }
    }
    
    /// Parses the original ASV table as generated by Kraken2 with the following format:
    /// U/C sequenceID taxon(taxID) length LCA (k-mer score string per taxon with the
    /// Lowest Common Ancestor)
    private static func parseASVStandard(line:String) throws -> KrakenASV  {
        let items = line.components(separatedBy: "\t")
        guard items.count == 5 else { throw RuntimeError("Invalid ASV file")}
        guard let taxonomy = KrakenASVTaxonomy(classification: items[2])
            else { throw RuntimeError("ASV with invalid taxonomy")}
        let size = Int(items[3].trimmingCharacters(in: .whitespaces)) ?? 0
        let asv = KrakenASV(sequenceID: items[1],
                            length: size,
                            taxonomy: taxonomy)
        return asv
    }
    
    /// Parses the original ASV table as generated by Kraken2 in the Epi2Me software
    /// with the following 6-column format:
    /// U/C sequenceID taxID length LCA lineage
    private static func parseEpi2Me(line:String) throws -> KrakenASV  {
        let items = line.components(separatedBy: "\t")
        guard items.count == 6 else { throw RuntimeError("Invalid ASV file")}
        let taxID = Int(items[2].trimmingCharacters(in: .whitespaces)) ?? 0
        let size = Int(items[3].trimmingCharacters(in: .whitespaces)) ?? 0
        let taxonomy = KrakenASVTaxonomy(taxID:taxID,
                                         classification: items[5])
        let asv = KrakenASV(sequenceID: items[1],
                            length: size,
                            taxonomy: taxonomy)
        return asv
    }
    
    /// Parses the parsed ASV table with the following layout:
    ///  - sequenceID:String
    ///  - length:Int
    ///  - assignedReads:Int
    ///  - taxID:Int
    ///  - taxon:String
    private static func parseParsedASV(line:String) throws -> KrakenASV  {
        let items = line.split(separator: "\t")
        guard items.count == 5
            else { throw RuntimeError("Invalid ASV line") }
        let sequenceID = items[0].trimmingCharacters(in: .whitespaces)
        let length = Int(items[1].trimmingCharacters(in: .whitespaces)) ?? 0
        let reads = Int(items[2].trimmingCharacters(in: .whitespaces)) ?? 0
        let taxID = Int(items[3].trimmingCharacters(in: .whitespaces)) ?? 0
        let classification = items[4].trimmingCharacters(in: .whitespaces)
        let taxonomy = KrakenASVTaxonomy(taxon: classification,
                                         taxID: taxID)
        let asv = KrakenASV(sequenceID: sequenceID,
                            length: length,
                            assignedReads: reads,
                            taxonomy: taxonomy)
        return asv
    }
}

extension KrakenASV: Equatable {
    static func == (lhs:KrakenASV, rhs:KrakenASV) -> Bool {
        if lhs.length == rhs.length {
            return lhs.sequenceID == rhs.sequenceID
        }
        return false
    }
    
    static func != (lhs:KrakenASV, rhs:KrakenASV) -> Bool {
        if lhs.length != rhs.length {
            return true
        }
        return lhs.sequenceID != rhs.sequenceID
    }
}

extension KrakenASV: Comparable {
    static func > (lhs:KrakenASV, rhs:KrakenASV) -> Bool {
        return lhs.length > rhs.length
    }
    
    static func < (lhs:KrakenASV, rhs:KrakenASV) -> Bool {
        return lhs.length < rhs.length
    }
}
